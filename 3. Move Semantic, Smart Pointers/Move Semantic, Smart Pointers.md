### Modern C++: Move Semantic. Smart Pointers
# Лабораторная работа № 3

Требуется выполнить как минимум одно задание.

**Код для этой и последующих лабортаторных работ нужно писать в соответствии с Code Standart-ом**

### 1. Copy smart pointer

Написать «умный» указатель, который при копировании будет копировать хранящиеся в нем данные.

```
template <class T> class CopyPtr
{
   ...
};
```

Указатель также должен реализовывать move-конструктор и move-оператор присваивания. Данные функции должны передавать владение другому указателю вместо копирования.

В указателе также должны быть реализованы стандартные операторы и методы: `*`, `->`, `Get`, `Reset`, преобразование к `bool`.

Написать код, который продемонстрирует работу указателя.

Пример использования:

```
CopyPtr<std::string> ptr(new std::string("text"));
```

*Дополнительное задание 1:* написать функцию `MakeCopyPtr`, аналогичную `std::make_unique` и `std::make_shared`.

*Дополнительное задание 2:* подумать, можно ли хранить указатель на базовый класс в таком «умном» указателе? Какие возникают проблемы и как их можно решить?

*Дополнительное задание 3:* сделать так, чтобы объект типа `CopyPtr<T>` можно было присвоить объекту `CopyPtr<const T>` и наоборот.
 
###	2. Caching factory

Написать «фабрику» `Factory`, которая умеет создавать объекты с интерфейсом `IAlgorithm`.

```
class IAlgorithm
{
public:
   virtual int Execute(int i_a, int i_b) = 0;
};

class Factory
{
public:
   shared_ptr<IAlgorithm> CreateAlgo(char i_op) { ... }
};
```

В качестве входного параметра фабрика должна принимать символ. Если передан символ ‘+’, то должен создаться объект, реализующий сложение; ‘-‘ – вычитание; ‘\*’ – умножение; ‘/’ – деление.

В программе запрещено использовать `new` и `delete`. Вместо них рекомендуется использование умных указателей и функции `std::make_shared`.

Фабрика должна иметь кэш созданных объектов на основе `std::shared_ptr`. Т.е. если объект уже был создан фабрикой и еще не удален, то следует вернуть указатель на этот объект.

Продемонстрировать работу фабрики. Проследить за временем жизни создаваемых объектов.

Пример использования:

```
int main(int argc, char* argv[])
{
   Factory factory;
   auto obj = factory.CreateAlgo('+');
   cout << obj->Execute(1, 2); // 3
   return 0;
}
```
*Дополнительное задание 1:* подумать, как можно обрабатывать деление на ноль.

*Дополнительное задание 2:* использовать `std::weak_ptr` вместо `std::shared_ptr` для кеша.

*Дополнительное задание 3:* сделать так, чтобы в кеше никогда не хранились "пустые" `std::weak_ptr`-ы на уже разрушенные объекты
